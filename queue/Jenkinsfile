pipeline {
  agent { label 'master' }

  parameters {
    string(name: 'ListOfJobs', defaultValue: '', description: 'Upstream JSON payload ({"jobs":[...]})')
  }

  options {
    timestamps()
    buildDiscarder(logRotator(numToKeepStr: '20', daysToKeepStr: '30'))
    disableConcurrentBuilds()
  }

  environment {
    QUEUE_PATH = 'queue.json'
  }

  stages {

     --------------------------------
     * Purge helper (run once then delete)
     * --------------------------------
    stage('PURGE QUEUE - RUN ONCE') {
      steps {
        script {
          writeFile file: env.QUEUE_PATH, text: '{"jobs":[],"deadLetter":[]}'
          echo "queue.json reset."
        }
      }
    }

    stage('Ingest to queue.json') {
      steps {
        script {
          if (!fileExists(env.QUEUE_PATH)) {
            writeFile file: env.QUEUE_PATH, text: '{"jobs":[],"deadLetter":[]}'
          }
          if (!params.ListOfJobs?.trim()) {
            echo 'No ListOfJobs provided; skipping ingest.'
            return
          }

          lock(resource: 'queue-json') {
            def curText = readFile(env.QUEUE_PATH)
            def cur     = parsePlainSafe(curText) ?: [jobs: [], deadLetter: []]
            if (!(cur.jobs instanceof List))       cur.jobs = []
            if (!(cur.deadLetter instanceof List)) cur.deadLetter = []
            cur.jobs = (cur.jobs as List).findAll { it instanceof Map && it.job != null }

            def incoming = parseJobsToPlain(params.ListOfJobs) // -> [jobs:[...]]
            def nowIso   = new Date().format("yyyy-MM-dd'T'HH:mm:ssXXX")

            int added = 0
            (incoming.jobs ?: []).each { j ->
              def item = toPlain(j) ?: [:]
              if (!(item.parameters instanceof List)) item.parameters = []

              // ensure env in parameters; default to 'staging'
              def envParam = item.parameters.find { it?.name?.toString() == 'env' }
              def envValue = envParam?.value?.toString()?.toLowerCase()
              if (!envValue) {
                envValue = 'staging'
                item.parameters << [name: 'env', value: envValue]
              }
              item.env = envValue

              // keep upstream priority as-is; null treated as 0 for sorting
              item.status     = 'queued'
              item.attempts   = (item.attempts ?: 0) as int
              item.receivedAt = item.receivedAt ?: nowIso

              if (!item.job) {
                item.error = 'missing job name (ingest)'
                (cur.deadLetter as List) << item
              } else {
                (cur.jobs as List) << item
                added++
              }
            }

            // sort: priority desc, then FIFO
            (cur.jobs as List).sort { x, y ->
              def a = (x instanceof Map) ? x : [:]
              def b = (y instanceof Map) ? y : [:]
              int pa = (a.priority ?: 0) as int
              int pb = (b.priority ?: 0) as int
              def byPrio = (pb <=> pa)
              (byPrio != 0) ? byPrio : ((a.receivedAt ?: '') <=> (b.receivedAt ?: ''))
            }

            writeFile file: env.QUEUE_PATH,
                     text: groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(cur))

            echo "Queue updated: added=${added}, totalQueued=${cur.jobs.count { it.status=='queued' }}, deadLetter=${(cur.deadLetter as List).size()}"
            echo "Current jobs: " + (cur.jobs as List).collect { it.name ?: it.job }.join(', ')
          } // lock
        }
      }
    }

    // Claim up to 4 live + up to 4 staging, store snapshots for matrix workers
    stage('Claim live & staging') {
      steps {
        script {
          lock(resource: 'queue-json') {
            def cur = parsePlainSafe(readFile(env.QUEUE_PATH)) ?: [jobs: [], deadLetter: []]
            if (!(cur.jobs instanceof List))       cur.jobs = []
            if (!(cur.deadLetter instanceof List)) cur.deadLetter = []

            def nowIso  = new Date().format("yyyy-MM-dd'T'HH:mm:ssXXX")
            def claimIdLive    = UUID.randomUUID().toString()
            def claimIdStaging = UUID.randomUUID().toString()

            // Always re-sort
            (cur.jobs as List).sort { x, y ->
              def a = (x instanceof Map) ? x : [:]
              def b = (y instanceof Map) ? y : [:]
              int pa = (a.priority ?: 0) as int
              int pb = (b.priority ?: 0) as int
              def byPrio = (pb <=> pa)
              (byPrio != 0) ? byPrio : ((a.receivedAt ?: '') <=> (b.receivedAt ?: ''))
            }

            // Pick top queued by env
            def liveQueued    = (cur.jobs as List).findAll { (it.status ?: 'queued') == 'queued' && (it.env ?: 'staging') == 'live' }
            def stagingQueued = (cur.jobs as List).findAll { (it.status ?: 'queued') == 'queued' && (it.env ?: 'staging') == 'staging' }

            def liveClaims    = liveQueued.take(4).collect   { toPlain(it) }
            def stagingClaims = stagingQueued.take(4).collect{ toPlain(it) }

            // Mark running in-place, mirror minimal snapshot
            liveClaims.each { c ->
              int idx = (cur.jobs as List).findIndexOf { j ->
                (j?.job?.toString()        == c.job?.toString()) &&
                ((j?.name?.toString() ?: '') == (c.name?.toString() ?: '')) &&
                (j?.receivedAt?.toString() == c.receivedAt?.toString()) &&
                ((j?.status ?: 'queued')   == 'queued') &&
                ((j?.env ?: 'staging')     == 'live')
              }
              if (idx >= 0) {
                cur.jobs[idx].status    = 'running'
                cur.jobs[idx].claimId   = claimIdLive
                cur.jobs[idx].startedAt = nowIso
                c.status    = 'running'
                c.claimId   = claimIdLive
                c.startedAt = nowIso
              }
            }

            stagingClaims.each { c ->
              int idx = (cur.jobs as List).findIndexOf { j ->
                (j?.job?.toString()        == c.job?.toString()) &&
                ((j?.name?.toString() ?: '') == (c.name?.toString() ?: '')) &&
                (j?.receivedAt?.toString() == c.receivedAt?.toString()) &&
                ((j?.status ?: 'queued')   == 'queued') &&
                ((j?.env ?: 'staging')     == 'staging')
              }
              if (idx >= 0) {
                cur.jobs[idx].status    = 'running'
                cur.jobs[idx].claimId   = claimIdStaging
                cur.jobs[idx].startedAt = nowIso
                c.status    = 'running'
                c.claimId   = claimIdStaging
                c.startedAt = nowIso
              }
            }

            writeFile file: env.QUEUE_PATH,
                     text: groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(cur))

            // Save snapshots for matrix branches (workers will NOT touch queue.json)
            writeFile file: 'live_claims.json',
                     text: groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(liveClaims))
            writeFile file: 'staging_claims.json',
                     text: groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(stagingClaims))

            // NEW: stash them so agents can fetch copies
            stash name: 'live-claims',    includes: 'live_claims.json',    allowEmpty: true
            stash name: 'staging-claims', includes: 'staging_claims.json', allowEmpty: true

            echo "Claimed live=${liveClaims.size()}, staging=${stagingClaims.size()}"


            echo "Claimed live=${liveClaims.size()}, staging=${stagingClaims.size()}"
          } // lock
        }
      }
    }

    // -------- LIVE POOL: agent-1..4 --------
    stage('LIVE pool (matrix)') {
      when {
        expression { fileExists('live_claims.json') && readFile('live_claims.json')?.trim() && readFile('live_claims.json').trim() != '[]' }
      }
      matrix {
        axes {
          axis {
            name 'AGENT_LABEL'
            values 'agent-1','agent-2','agent-3','agent-4'
          }
        }
        agent { label "${AGENT_LABEL}" }

        stages {
          stage('Live worker') {
            steps {
              script {
                unstash 'live-claims'   // NEW
                def claims = parsePlainSafe(readFile('live_claims.json')) as List
                int myIndex = indexFromAgent(env.AGENT_LABEL) // agent-1->0, agent-2->1, ...
                if (myIndex < 0 || myIndex >= claims.size()) {
                  echo "[${env.AGENT_LABEL}] No assigned live item; skipping."
                  return
                }

                def item    = claims[myIndex]
                def jobName = item.job.toString()
                def plist   = (item.parameters ?: []).collect { kv ->
                  string(name: kv.name.toString(), value: (kv.value == null ? '' : kv.value.toString()))
                }

                boolean ok = true
                String err = null
                try {
                  echo "[${env.AGENT_LABEL}] ▶ LIVE ${item.name ?: jobName} (prio=${item.priority ?: 0})"
                  build job: jobName, wait: true, propagate: true, parameters: plist
                  echo "[${env.AGENT_LABEL}] ✔ LIVE done ${item.name ?: jobName}"
                } catch (e) {
                  ok = false
                  err = e.getMessage()
                  echo "[${env.AGENT_LABEL}] ✖ LIVE fail ${item.name ?: jobName}: ${err}"
                }

                // finalize on master
                node('master') {
                  lock(resource: 'queue-json') {
                    def cur = parsePlainSafe(readFile(env.QUEUE_PATH)) ?: [jobs: [], deadLetter: []]
                    if (!(cur.jobs instanceof List))       cur.jobs = []
                    if (!(cur.deadLetter instanceof List)) cur.deadLetter = []

                    int idx = (cur.jobs as List).findIndexOf { j ->
                      (j?.status == 'running') &&
                      (j?.claimId?.toString()   == item.claimId?.toString()) &&
                      (j?.job?.toString()       == jobName) &&
                      ((j?.name?.toString() ?: '') == (item.name?.toString() ?: ''))
                    }

                    if (idx >= 0) {
                      def j = cur.jobs[idx]
                      if (ok) {
                        cur.jobs.remove(idx)
                      } else {
                        int attempts = ((j.attempts ?: 0) as int) + 1
                        j.attempts = attempts
                        if (attempts >= 3) {
                          j.status = 'failed'
                          j.error  = err ?: 'unknown'
                          (cur.deadLetter as List) << j
                          cur.jobs.remove(idx)
                        } else {
                          j.status    = 'queued'
                          j.claimId   = null
                          j.startedAt = null
                          cur.jobs[idx] = j
                        }
                      }
                      writeFile file: env.QUEUE_PATH,
                               text: groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(cur))
                    } else {
                      echo "[${env.AGENT_LABEL}] WARN: Claimed LIVE item not found during finalize."
                    }
                  } // lock
                } // node master
              } // script
            } // steps
          } // stage
        } // stages
      } // matrix
    }

    // -------- STAGING POOL: staging-1..4 --------
    stage('STAGING pool (matrix)') {
      when {
        expression { fileExists('staging_claims.json') && readFile('staging_claims.json')?.trim() && readFile('staging_claims.json').trim() != '[]' }
      }
      matrix {
        axes {
          axis {
            name 'AGENT_LABEL'
            values 'staging-1','staging-2','staging-3','staging-4'
          }
        }
        agent { label "${AGENT_LABEL}" }

        stages {
          stage('Staging worker') {
            steps {
              script {
                unstash 'staging-claims'   // NEW
                def claims = parsePlainSafe(readFile('staging_claims.json')) as List
                int myIndex = indexFromAgent(env.AGENT_LABEL) // staging-1->0, ...
                if (myIndex < 0 || myIndex >= claims.size()) {
                  echo "[${env.AGENT_LABEL}] No assigned staging item; skipping."
                  return
                }

                def item    = claims[myIndex]
                def jobName = item.job.toString()
                def plist   = (item.parameters ?: []).collect { kv ->
                  string(name: kv.name.toString(), value: (kv.value == null ? '' : kv.value.toString()))
                }

                boolean ok = true
                String err = null
                try {
                  echo "[${env.AGENT_LABEL}] ▶ STAGING ${item.name ?: jobName} (prio=${item.priority ?: 0})"
                  build job: jobName, wait: true, propagate: true, parameters: plist
                  echo "[${env.AGENT_LABEL}] ✔ STAGING done ${item.name ?: jobName}"
                } catch (e) {
                  ok = false
                  err = e.getMessage()
                  echo "[${env.AGENT_LABEL}] ✖ STAGING fail ${item.name ?: jobName}: ${err}"
                }

                // finalize on master
                node('master') {
                  lock(resource: 'queue-json') {
                    def cur = parsePlainSafe(readFile(env.QUEUE_PATH)) ?: [jobs: [], deadLetter: []]
                    if (!(cur.jobs instanceof List))       cur.jobs = []
                    if (!(cur.deadLetter instanceof List)) cur.deadLetter = []

                    int idx = (cur.jobs as List).findIndexOf { j ->
                      (j?.status == 'running') &&
                      (j?.claimId?.toString()   == item.claimId?.toString()) &&
                      (j?.job?.toString()       == jobName) &&
                      ((j?.name?.toString() ?: '') == (item.name?.toString() ?: ''))
                    }

                    if (idx >= 0) {
                      def j = cur.jobs[idx]
                      if (ok) {
                        cur.jobs.remove(idx)
                      } else {
                        int attempts = ((j.attempts ?: 0) as int) + 1
                        j.attempts = attempts
                        if (attempts >= 3) {
                          j.status = 'failed'
                          j.error  = err ?: 'unknown'
                          (cur.deadLetter as List) << j
                          cur.jobs.remove(idx)
                        } else {
                          j.status    = 'queued'
                          j.claimId   = null
                          j.startedAt = null
                          cur.jobs[idx] = j
                        }
                      }
                      writeFile file: env.QUEUE_PATH,
                               text: groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(cur))
                    } else {
                      echo "[${env.AGENT_LABEL}] WARN: Claimed STAGING item not found during finalize."
                    }
                  } // lock
                } // node master
              } // script
            } // steps
          } // stage
        } // stages
      } // matrix
    }

  } // stages
}

/* ----------------------- Helpers (CPS-safe) ----------------------- */

@NonCPS
def parseJobsToPlain(String raw) {
  def sl = new groovy.json.JsonSlurper()
  Object obj
  try { obj = sl.parseText(raw?.trim()) } catch (e) {
    throw new Exception("Invalid JSON (${e.message}). First 200 chars: ${raw?.take(200)}")
  }
  if (obj instanceof String) obj = sl.parseText(obj) // handle double-encoded
  if (obj instanceof List)   obj = [jobs: obj]
  else if (!(obj instanceof Map) || !(obj.jobs instanceof List))
    throw new Exception('Expected top-level {"jobs":[...]} or a bare array.')
  return toPlain(obj)
}

@NonCPS
def parsePlainSafe(String text) {
  if (!text) return null
  try {
    def p = new groovy.json.JsonSlurper().parseText(text.trim())
    if (p instanceof String) p = new groovy.json.JsonSlurper().parseText(p)
    return toPlain(p)
  } catch (ignored) { return null }
}

@NonCPS
def toPlain(Object o) {
  if (o instanceof Map)  { def m = [:]; o.each { k,v -> m[(k?.toString())] = toPlain(v) }; return m }
  if (o instanceof List) { return o.collect { toPlain(it) } }
  return o
}

// agent-1 -> 0, agent-2 -> 1, staging-1 -> 0, ...
@NonCPS
def indexFromAgent(String label) {
  if (!label) return -1
  try {
    def parts = label.split('-')
    return Math.max(0, Integer.parseInt(parts[-1]) - 1)
  } catch (ignored) {
    return -1
  }
}

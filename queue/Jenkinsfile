pipeline {
  agent { label 'master' }

  parameters {
    string(name: 'ListOfJobs', defaultValue: '', description: 'Upstream JSON payload ({"jobs":[...]})')
  }

  options {
    timestamps()
    buildDiscarder(logRotator(numToKeepStr: '20', daysToKeepStr: '30'))
  }

  environment {
    QUEUE_PATH = 'queue.json'
  }

  stages {
    stage('Ingest to queue.json') {
      steps {
        script {
          if (!params.ListOfJobs?.trim()) {
            error 'ListOfJobs is empty; expected JSON payload from upstream.'
          }

          if (!fileExists(env.QUEUE_PATH)) {
            writeFile file: env.QUEUE_PATH, text: '{"jobs":[],"deadLetter":[]}'
          }

          lock(resource: 'queue-json') {
            def curText = readFile(env.QUEUE_PATH)
            def curRaw  = parsePlainSafe(curText)

            // normalize current queue
            def cur
            if (curRaw instanceof Map)      cur = curRaw
            else if (curRaw instanceof List) cur = [jobs: curRaw, deadLetter: []]
            else                             cur = [jobs: [],  deadLetter: []]

            if (!(cur.jobs instanceof List))       cur.jobs = []
            if (!(cur.deadLetter instanceof List)) cur.deadLetter = []

            // remove junk
            cur.jobs = (cur.jobs as List).findAll { it instanceof Map && it.job != null }

            // parse incoming
            def incoming = parseJobsToPlain(params.ListOfJobs) // => [jobs:[...]]
            def nowIso = new Date().format("yyyy-MM-dd'T'HH:mm:ssXXX")

            int added = 0
            (incoming.jobs ?: []).each { j ->
              def item = toPlain(j) ?: [:]
              if (!(item.parameters instanceof List)) item.parameters = []

              // ensure env is inside parameters; default to staging if missing
              def envParam = item.parameters.find { it?.name?.toString() == 'env' }
              def envValue = envParam?.value?.toString()?.toLowerCase()
              if (!envValue) {
                envValue = 'staging'
                item.parameters << [name: 'env', value: envValue]
              }
              item.env = envValue // top-level copy for filtering later

              // priority is assumed provided by upstream; if absent/malformed, keep null-safe 6
              def pr = 6
              try { pr = (item.priority as Integer) ?: 6 } catch (ignored) {}
              item.priority  = pr
              item.status    = 'queued'
              item.attempts  = (item.attempts ?: 0) as int
              item.receivedAt = item.receivedAt ?: nowIso

              if (!item.job) {
                item.error = 'missing job name (ingest)'
                (cur.deadLetter as List) << item
              } else {
                (cur.jobs as List) << item
                added++
              }
            }

            // sort: priority desc, then FIFO
            (cur.jobs as List).sort { x, y ->
              def a = (x instanceof Map) ? x : [:]
              def b = (y instanceof Map) ? y : [:]
              int pa = (a.priority ?: 0) as int
              int pb = (b.priority ?: 0) as int
              def byPrio = (pb <=> pa)
              (byPrio != 0) ? byPrio : ((a.receivedAt ?: '') <=> (b.receivedAt ?: ''))
            }

            def outText = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(cur))
            writeFile file: env.QUEUE_PATH, text: outText

            echo "Queue updated: added=${added}, totalQueued=${cur.jobs.count { it.status=='queued' }}, deadLetter=${(cur.deadLetter as List).size()}"
            def names = (cur.jobs as List).collect { it.name ?: it.job }.join(', ')
            echo "Current jobs: ${names}"
          } // lock
        }
      }
    }

    stage('Dispatch top 3') {
      steps {
        script {
          // 1) Claim up to 3 queued items under lock
          def claimed = []
          def claimId = UUID.randomUUID().toString()

          lock(resource: 'queue-json') {
            def cur = parsePlainSafe(readFile(env.QUEUE_PATH)) ?: [jobs: [], deadLetter: []]
            if (!(cur.jobs instanceof List))       cur.jobs = []
            if (!(cur.deadLetter instanceof List)) cur.deadLetter = []
            cur.jobs = (cur.jobs as List).findAll { it instanceof Map && it.job != null }

            // ensure sorted
            (cur.jobs as List).sort { x, y ->
              def a = (x instanceof Map) ? x : [:]
              def b = (y instanceof Map) ? y : [:]
              int pa = (a.priority ?: 0) as int
              int pb = (b.priority ?: 0) as int
              def byPrio = (pb <=> pa)
              (byPrio != 0) ? byPrio : ((a.receivedAt ?: '') <=> (b.receivedAt ?: ''))
            }

            // pick top 3 queued
            def queued = (cur.jobs as List).findAll { (it.status ?: 'queued') == 'queued' }
            claimed = queued.take(3).collect { toPlain(it) }

            // mark running
            claimed.each { it.status = 'running'; it.claimId = claimId; it.startedAt = new Date().format("yyyy-MM-dd'T'HH:mm:ssXXX") }

            // write back with running status for claimed items
            def updated = (cur.jobs as List).collect { j ->
              def k = claimed.find { it.is(j) || (it.name == j.name && it.receivedAt == j.receivedAt && it.job == j.job) }
              k ? k : j
            }
            cur.jobs = updated

            writeFile file: env.QUEUE_PATH,
                     text: groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(cur))
          } // lock

          if (!claimed || claimed.isEmpty()) {
            echo "No queued items to dispatch."
            return
          }

          echo "Dispatching ${claimed.size()} job(s): ${claimed.collect { it.name ?: it.job }.join(', ')}"

          // 2) Run each claimed job (sequentially for now)
          claimed.each { item ->
            def jobName = item.job.toString()
            def plist   = (item.parameters ?: []).collect { kv ->
              string(name: kv.name.toString(), value: (kv.value == null ? '' : kv.value.toString()))
            }

            boolean ok = true
            String err = null
            try {
              echo "▶ Running ${item.name ?: jobName} -> ${jobName} (priority=${item.priority}, env=${item.env})"
              build job: jobName, wait: true, propagate: true, parameters: plist
              echo "✔ Success ${item.name ?: jobName}"
            } catch (e) {
              ok = false
              err = e.getMessage()
              echo "✖ Failure ${item.name ?: jobName}: ${err}"
            }

            // 3) Finalize result under lock
            lock(resource: 'queue-json') {
              def cur = parsePlainSafe(readFile(env.QUEUE_PATH)) ?: [jobs: [], deadLetter: []]
              if (!(cur.jobs instanceof List))       cur.jobs = []
              if (!(cur.deadLetter instanceof List)) cur.deadLetter = []

              // find the running entry by claimId + name + job
              int idx = (cur.jobs as List).findIndexOf {
                (it?.status == 'running') &&
                (it?.claimId?.toString() == item.claimId?.toString()) &&
                (it?.job?.toString() == jobName) &&
                ((it?.name?.toString() ?: '') == (item.name?.toString() ?: ''))
              }

              if (idx >= 0) {
                def j = cur.jobs[idx]
                if (ok) {
                  // remove on success
                  cur.jobs.remove(idx)
                } else {
                  // retry up to 3 attempts
                  int attempts = ((j.attempts ?: 0) as int) + 1
                  j.attempts = attempts
                  if (attempts >= 3) {
                    j.status = 'failed'
                    j.error  = err ?: 'unknown'
                    (cur.deadLetter as List) << j
                    cur.jobs.remove(idx)
                  } else {
                    j.status   = 'queued'
                    j.claimId  = null
                    j.startedAt = null
                    cur.jobs[idx] = j
                  }
                }

                writeFile file: env.QUEUE_PATH,
                         text: groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(cur))
              } else {
                echo "WARN: Claimed item not found during finalize (already modified by another run?)."
              }
            } // lock finalize
          } // each claimed
        } // script
      } // steps
    } // stage
  } // stages
}

/* ----------------------- Helpers (CPS-safe) ----------------------- */

@NonCPS
def parseJobsToPlain(String raw) {
  def sl = new groovy.json.JsonSlurper()
  Object obj
  try { obj = sl.parseText(raw?.trim()) } catch (e) {
    throw new Exception("Invalid JSON (${e.message}). First 200 chars: ${raw?.take(200)}")
  }
  if (obj instanceof String) obj = sl.parseText(obj) // double-encoded
  if (obj instanceof List)   obj = [jobs: obj]
  else if (!(obj instanceof Map) || !(obj.jobs instanceof List))
    throw new Exception('Expected top-level {"jobs":[...]} or a bare array.')
  return toPlain(obj)
}

@NonCPS
def parsePlainSafe(String text) {
  if (!text) return null
  try {
    def p = new groovy.json.JsonSlurper().parseText(text.trim())
    if (p instanceof String) p = new groovy.json.JsonSlurper().parseText(p)
    return toPlain(p)
  } catch (ignored) { return null }
}

@NonCPS
def toPlain(Object o) {
  if (o instanceof Map)  { def m = [:]; o.each { k,v -> m[(k?.toString())] = toPlain(v) }; return m }
  if (o instanceof List) { return o.collect { toPlain(it) } }
  return o
}

pipeline {
  agent { label 'master' }
  parameters {
    string(name: 'ListOfJobs', defaultValue: '', description: 'Upstream JSON')
  }
  options {
    buildDiscarder(logRotator(numToKeepStr: '15', daysToKeepStr: '30'))
  }
  environment {
    BUILD_TRIGGER_BY = 'unknown' // avoid calling methods here
  }
  stages {
    stage('prep') {
      steps {
        script {
          if (!params.ListOfJobs?.trim()) {
            error 'ListOfJobs is empty; expected JSON payload from upstream.'
          }

          // Parse + normalize to: [jobs: <List>]
          def incomingJobs = parseJobsToPlain(params.ListOfJobs)

          def stagingJobs = incomingJobs.jobs.findAll { job ->
            (job.parameters ?: []).find { p -> p.name == 'env' && p.value?.toString()?.toLowerCase() == 'staging' }
          }
          def liveJobs = incomingJobs.jobs.findAll { job ->
            (job.parameters ?: []).find { p -> p.name == 'env' && p.value?.toString()?.toLowerCase() == 'live' }
          }

          echo "Staging jobs: ${stagingJobs.collect { it.name ?: it.job }}"
          echo "Live jobs: ${liveJobs.collect { it.name ?: it.job }}"
        }
      }
    }
    stage('live run') {
      steps {
        script {
          echo "Live run for jobs: ${liveJobs}" 
        }
      }
    }
    stage('staging run') {
      steps { 
        script {
          echo "Staging run for jobs: ${stagingJobs}" 
        }
      }
    }
  }
}

// ---- Helpers (no plugins, CPS-safe) ----
@NonCPS
def parseJobsToPlain(String raw) {
  def slurper = new groovy.json.JsonSlurper()
  Object obj
  try {
    obj = slurper.parseText(raw)
  } catch (e) {
    throw new Exception("Invalid JSON (${e.message}). First 200 chars: ${raw.take(200)}")
  }

  // Handle double-encoded JSON strings like "\"{...}\"" or "\"[...]\""
  if (obj instanceof String) {
    obj = slurper.parseText(obj)
  }

  // Accept either { "jobs": [...] } or bare [...] and wrap it
  if (obj instanceof List) {
    obj = [jobs: obj]
  } else if (!(obj instanceof Map) || !(obj.jobs instanceof List)) {
    throw new Exception("Expected top-level {\"jobs\":[...] } or a bare [ ... ]. Got ${obj?.getClass()?.name}.")
  }

  // Deep-convert LazyMap to plain Maps/Lists
  return toPlain(obj)
}

@NonCPS
def toPlain(Object obj) {
  if (obj instanceof Map) {
    def m = [:]
    obj.each { key, value -> m[key?.toString()] = toPlain(value) }
    return m
  } else if (obj instanceof List) {
    return obj.collect { toPlain(it) }
  } else {
    return obj  // primitives/strings
  }
}

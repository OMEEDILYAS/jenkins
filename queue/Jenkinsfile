pipeline{
  agent {
    label 'master'
  }
  parameters {
    string(name: 'ListOfJobs', defaultValue: '', description: 'upstream jobs to run')
  }
  options {
    buildDiscarder(logRotator(numToKeepStr: '15', daysToKeepStr: '30'))
  }
  environment {
    BUILD_TRIGGER_BY = "${currentBuild.getBuildCauses()[0].userId}"
  }
  stages {
    stage('prep'){
      steps {
        script {
          try{
            def incomingJobs = new groovy.json.JsonSlurper().parseText(params.ListOfJobs)
            echo "Incoming jobs type: ${incomingJobs.getClass()}"
            echo "Incoming jobs content: ${incomingJobs}"
            if (!(incomingJobs instanceof List || incomingJobs instanceof Map)) {
              error "ListOfJobs parameter is not a valid JSON array or object."
            }
            echo "Prepared jobs: ${incomingJobs}"
            incomingJobs = toPlain(incomingJobs)
            echo "Converted jobs to plain object: ${incomingJobs}"

            def stagingJobs = incoming_jobs.findAll { it.parameters.find { param -> param.name == 'Env_TO_RUN' && param.value == 'staging' } }
            def liveJobs = incoming_jobs.findAll { it.parameters.find { param -> param.name == 'Env_TO_RUN' && param.value == 'live' } }
            echo "Staging jobs: ${stagingJobs}"
            echo "Live jobs: ${liveJobs}"
          } catch (Exception e) {
            error "Error parsing ListOfJobs parameter: ${e.message}"
          }
        }
      }
    }
    stage('live run') {
      steps {
        script {
          echo "Live run for jobs: ${params.ListOfJobs}"
        }
      }
    }
    stage('staging run') {
      steps {
        script {
          echo "Staging run for jobs: ${params.ListOfJobs}"
        }
      }
    }
  }
}
@NonCPS
def toPlain(Object obj) {
  echo "Converting to plain object: ${obj}"
  if (obj instanceof Map) {
    def plainMap = [:]
    obj.each { key, value ->
      plainMap[(k?.toString())] = toPlain(value)
    }
    return plainMap
  } else if (obj instanceof List) {
    def plainList = []
    obj.each { item ->
      plainList.add(toPlain(item))
    }
    return plainList
  } else {
    error " passed down jobs are not in expected format. ${obj.getClass()}"
  }
}

pipeline {
  agent any
  options { timestamps(); disableConcurrentBuilds() }

  parameters {
    string(name: 'BATCH_JSON', defaultValue: '', description: 'Raw JSON payload from a scheduler (jobs array).')
    string(name: 'SOURCE',     defaultValue: '', description: 'every_15m | hourly | daily | weekly')
  }

  stages {
    stage('Ingest batch') {
      when { expression { return params.BATCH_JSON?.trim() } }
      steps {
        script {
          echo "Ingesting batch from source='${params.SOURCE}' (size=${params.BATCH_JSON.length()})"

          def queuePath = 'queue/queue.json'
          def existingText = fileExists(queuePath) ? readFile(queuePath) : ''
          if (!existingText?.trim()) {
            echo "Queue file missing/blank. Initializing to {\"jobs\":[], \"deadLetter\":[]}"
            existingText = '{"jobs":[], "deadLetter":[]}'
          }

          withQueueLock {
            def curText = fileExists(queuePath) ? readFile(queuePath) : existingText
            if (!curText?.trim()) curText = existingText

            def mergedJson = safeMerge(curText, params.BATCH_JSON, params.SOURCE)
            def pretty = groovy.json.JsonOutput.prettyPrint(mergedJson)
            writeFile file: queuePath, text: pretty
            echo "Queue updated at ${queuePath}"
          }
        }
      }
    }

    /* ====================== MATRIX: one worker per agent ====================== */
    stage('Process queue (tokens)') {
      matrix {
        axes {
          axis {
            name 'TOKEN'
            values 'agent-1','agent-2','agent-3','agent-4'   // <--- your agents
          }
        }
        // Run each matrix leg on its matching agent label
        agent { label "${TOKEN}" }

        stages {
          stage('Worker loop') {
            steps {
              script { workerLoop(env.TOKEN as String) }
            }
          }
        }
      }
    }
  }
}

/* ============================ Worker Logic ============================ */

def workerLoop(String tokenId) {
  def queuePath = 'queue/queue.json'
  int idleRounds = 0
  int maxIdleRounds = 3  // stop after a few idle checks with no work

  while (true) {
    def jobItem = null

    withQueueLock {
      if (!fileExists(queuePath)) return
      def qText = readFile(queuePath)
      if (!qText?.trim()) return

      def q = parsePlainSafe(qText) ?: [jobs: [], deadLetter: []]
      if (!(q.jobs instanceof List)) q.jobs = []
      if (!(q.deadLetter instanceof List)) q.deadLetter = []

      // Highest priority first; FIFO within same priority
      q.jobs.sort { a, b ->
        int pa = (a.priority ?: 0) as int
        int pb = (b.priority ?: 0) as int
        def byPrio = (pb <=> pa)
        if (byPrio != 0) return byPrio
        (a.receivedAt ?: '') <=> (b.receivedAt ?: '')
      }

      // pick first non-running
      int idx = q.jobs.findIndexOf { it.status == null || it.status == 'queued' }
      if (idx == -1) {
        jobItem = null
      } else {
        jobItem = q.jobs[idx]
        jobItem.status    = 'running'
        jobItem.processor = tokenId
        jobItem.attempts  = ((jobItem.attempts ?: 0) as int) + 1

        def newText = toJsonString([jobs: q.jobs, deadLetter: q.deadLetter])
        writeFile file: queuePath, text: groovy.json.JsonOutput.prettyPrint(newText)
      }
    } // lock released

    if (jobItem == null) {
      idleRounds++
      if (idleRounds >= maxIdleRounds) {
        echo "[${tokenId}] No jobs available. Exiting."
        break
      }
      sleep time: 5, unit: 'SECONDS'
      continue
    }

    idleRounds = 0 // got work

    // ---- Execute outside the lock ----
    def jobName  = jobItem.job.toString()
    def waitFlag = !!jobItem.wait
    def params   = buildParams(jobItem.parameters)

    echo "[${tokenId}] ▶ RUN ${jobItem.name} from ${jobItem.source} -> ${jobName} (priority=${jobItem.priority}, attempt=${jobItem.attempts}, wait=${waitFlag})"

    boolean ok = true
    String errMsg = null
    try {
      build job: jobName, wait: waitFlag, propagate: true, parameters: params
      echo "[${tokenId}] ✔ DONE ${jobItem.name}"
    } catch (e) {
      ok = false
      errMsg = e.getMessage()
      echo "[${tokenId}] ✖ FAIL ${jobItem.name} : ${errMsg}"
    }

    // ---- Persist outcome ----
    withQueueLock {
      def qText2 = fileExists(queuePath) ? readFile(queuePath) : '{"jobs":[], "deadLetter":[]}'
      def q2 = parsePlainSafe(qText2) ?: [jobs: [], deadLetter: []]
      if (!(q2.jobs instanceof List)) q2.jobs = []
      if (!(q2.deadLetter instanceof List)) q2.deadLetter = []

      int idx2 = q2.jobs.findIndexOf {
        it.name?.toString()      == jobItem.name?.toString() &&
        (it.receivedAt ?: '')    == (jobItem.receivedAt ?: '') &&
        (it.processor ?: '')     == tokenId &&
        (it.status ?: '')        == 'running'
      }

      if (idx2 == -1) {
        echo "[${tokenId}] WARN: Claimed item not found during finalize; writing best-effort state."
        if (!ok) { (q2.deadLetter as List) << (jobItem + [error: (errMsg ?: 'unknown')]) }
      } else {
        def running = q2.jobs.remove(idx2)

        if (ok) {
          // success => removed
        } else {
          int attempts = (running.attempts ?: 1) as int
          if (attempts >= 3) {
            running.status = 'failed'
            running.error  = errMsg
            (q2.deadLetter as List) << running
          } else {
            running.status    = 'queued'
            running.processor = null
            q2.jobs << running
          }
        }
      }

      def newText2 = toJsonString([jobs: q2.jobs, deadLetter: q2.deadLetter])
      writeFile file: queuePath, text: groovy.json.JsonOutput.prettyPrint(newText2)
    }
  }
}

/* ============================ Cross-platform Lock ============================ */

def withQueueLock(Closure body) {
  def lockDir = "${pwd()}/queue/.lock"
  lockDir = lockDir.replace('\\','/')

  int attempts = 0
  int maxAttempts = 120

  while (true) {
    int code
    if (isUnix()) {
      code = sh(script: "mkdir '${lockDir}' 2>/dev/null && exit 0 || exit 1", returnStatus: true)
    } else {
      code = powershell(returnStatus: true, script: """
        try { New-Item -ItemType Directory -Path '${lockDir}' -ErrorAction Stop | Out-Null; exit 0 }
        catch { exit 1 }
      """.stripIndent())
    }
    if (code == 0) break
    attempts++
    if (attempts >= maxAttempts) { error "Could not acquire queue lock at ${lockDir}" }
    sleep time: 1, unit: 'SECONDS'
  }

  try {
    body.call()
  } finally {
    if (isUnix()) {
      sh     script: "rm -rf '${lockDir}' || true"
    } else {
      powershell script: "Remove-Item -LiteralPath '${lockDir}' -Force -Recurse -ErrorAction SilentlyContinue"
    }
  }
}

/* ============================ JSON Helpers ============================ */

def buildParams(List plist) {
  def m = [:]
  (plist ?: []).each { kv ->
    if (kv?.name) m[kv.name.toString()] = (kv.value == null ? '' : kv.value.toString())
  }
  return [
    string(name: 'PARAM1', value: m['PARAM1'] ?: ''),
    string(name: 'PARAM2', value: m['PARAM2'] ?: ''),
    string(name: 'PARAM3', value: m['PARAM3'] ?: ''),
    string(name: 'PARAM4', value: m['PARAM4'] ?: '')
  ]
}

@NonCPS
def safeMerge(String existingText, String batchText, String source) {
  def existing = parsePlainSafe(existingText) ?: [jobs: [], deadLetter: []]
  if (!(existing.jobs instanceof List)) existing.jobs = []
  if (!(existing.deadLetter instanceof List)) existing.deadLetter = []

  def batch = parsePlainSafe(batchText) ?: [jobs: []]
  def now = new Date().format("yyyy-MM-dd'T'HH:mm:ssXXX")

  (batch.jobs ?: []).each { j ->
    def item = toPlain(j) ?: [:]
    if (!(item.parameters instanceof List)) item.parameters = []
    item.source     = source?.toString()
    item.receivedAt = now
    item.status     = 'queued'
    item.attempts   = 0
    existing.jobs << item
  }

  return groovy.json.JsonOutput.toJson(existing)
}

@NonCPS
def parsePlainSafe(String jsonText) {
  if (!jsonText) return null
  def t = jsonText.trim()
  if (t.length() == 0) return null
  try {
    def p = new groovy.json.JsonSlurper().parseText(t)
    return toPlain(p)
  } catch (Throwable ignored) {
    return null
  }
}

@NonCPS
def toPlain(Object o) {
  if (o instanceof Map)  { def m = [:]; o.each { k,v -> m[(k?.toString())] = toPlain(v) }; return m }
  if (o instanceof List) { def l = [];  o.each { v -> l << toPlain(v) }; return l }
  return o
}

@NonCPS
def toJsonString(Object o) { groovy.json.JsonOutput.toJson(o) }
// Jenkinsfile — Option B: shared queue via stash/unstash + improvements
pipeline {
  agent any
  options { timestamps(); disableConcurrentBuilds() }

  parameters {
    string(name: 'BATCH_JSON', defaultValue: '', description: 'Raw JSON payload from a scheduler (jobs array).')
    string(name: 'SOURCE',     defaultValue: '', description: 'every_15m | hourly | daily | weekly')
    string(name: 'IDLE_ROUNDS', defaultValue: '24', description: 'How many 5s idle checks before a worker leg exits (default ~2min).')
  }

  stages {
    stage('Ingest batch') {
      when { expression { return params.BATCH_JSON?.trim() } }
      steps {
        script {
          echo "Ingesting batch from source='${params.SOURCE}' (size=${params.BATCH_JSON.length()})"

          withStashedQueue {
            // Load or init
            def qText = fileExists('queue.json') ? readFile('queue.json') : ''
            if (!qText?.trim()) {
              qText = '{"jobs":[],"deadLetter":[]}'
            }

            // Merge new jobs
            def merged = safeMerge(qText, params.BATCH_JSON, params.SOURCE)
            def pretty = groovy.json.JsonOutput.prettyPrint(merged)

            writeFile file: 'queue.json', text: pretty
          }

          echo "Queue updated."
        }
      }
    }

    stage('Process queue (tokens)') {
      matrix {
        axes {
          axis {
            name 'TOKEN'
            values 'agent-1', 'agent-2', 'agent-3', 'agent-4'
          }
        }
        agent { label "${TOKEN}" }

        stages {
          stage('Worker loop') {
            steps {
              script { workerLoop(env.TOKEN as String, (params.IDLE_ROUNDS ?: '24') as int) }
            }
          }
        }
      }
    }
  }
}

/* ============================ Worker Logic ============================ */

def workerLoop(String tokenId, int maxIdleRounds) {
  int idleRounds = 0

  while (true) {
    def jobItem = null

    // -------- Claim a job (under lock; queue materialized via unstash) --------
    withStashedQueue {
      def qText = fileExists('queue.json') ? readFile('queue.json') : '{"jobs":[],"deadLetter":[]}'
      def q = parsePlainSafe(qText) ?: [jobs: [], deadLetter: []]
      if (!(q.jobs instanceof List)) q.jobs = []
      if (!(q.deadLetter instanceof List)) q.deadLetter = []

      // Highest priority first; FIFO by receivedAt within same priority
      q.jobs.sort { a, b ->
        int pa = (a.priority ?: 0) as int
        int pb = (b.priority ?: 0) as int
        def byPrio = (pb <=> pa)
        if (byPrio != 0) return byPrio
        (a.receivedAt ?: '') <=> (b.receivedAt ?: '')
      }

      // Find first non-running job
      int idx = q.jobs.findIndexOf { it.status == null || it.status == 'queued' }
      if (idx != -1) {
        jobItem = q.jobs[idx]
        jobItem.status    = 'running'
        jobItem.processor = tokenId
        jobItem.attempts  = ((jobItem.attempts ?: 0) as int) + 1
        // Persist claim
        writeFile file: 'queue.json', text: groovy.json.JsonOutput.prettyPrint(toJsonString([jobs: q.jobs, deadLetter: q.deadLetter]))
      }
    } // lock releases here

    if (jobItem == null) {
      idleRounds++
      if (idleRounds >= Math.max(1, maxIdleRounds)) {
        echo "[${tokenId}] No jobs available after ${idleRounds} checks. Exiting."
        break
      }
      sleep time: 5, unit: 'SECONDS'
      continue
    }

    idleRounds = 0 // got work

    // ---- Execute outside the lock ----
    def jobName  = jobItem.job?.toString()
    def waitFlag = !!jobItem.wait
    def params   = buildParams(jobItem.parameters)

    echo "[${tokenId}] ▶ RUN ${jobItem.name} src=${jobItem.source} -> ${jobName} (prio=${jobItem.priority}, attempt=${jobItem.attempts}, wait=${waitFlag})"

    boolean ok = true
    String errMsg = null
    try {
      build job: jobName, wait: waitFlag, propagate: true, parameters: params
      echo "[${tokenId}] ✔ DONE ${jobItem.name}"
    } catch (e) {
      ok = false
      errMsg = e.getMessage()
      echo "[${tokenId}] ✖ FAIL ${jobItem.name} : ${errMsg}"
    }

    // ---- Finalize outcome (under lock) ----
    withStashedQueue {
      def qText2 = fileExists('queue.json') ? readFile('queue.json') : '{"jobs":[],"deadLetter":[]}'
      def q2 = parsePlainSafe(qText2) ?: [jobs: [], deadLetter: []]
      if (!(q2.jobs instanceof List)) q2.jobs = []
      if (!(q2.deadLetter instanceof List)) q2.deadLetter = []

      // Find the running record we claimed
      int idx2 = q2.jobs.findIndexOf {
        it.name?.toString()   == jobItem.name?.toString() &&
        (it.receivedAt ?: '') == (jobItem.receivedAt ?: '') &&
        (it.processor ?: '')  == tokenId &&
        (it.status ?: '')     == 'running'
      }

      if (idx2 == -1) {
        echo "[${tokenId}] WARN: Claimed item not found during finalize; best-effort write."
        if (!ok) { (q2.deadLetter as List) << (jobItem + [status: 'failed', error: (errMsg ?: 'unknown')]) }
      } else {
        def running = q2.jobs.remove(idx2)
        if (ok) {
          // success => drop
        } else {
          int attempts = (running.attempts ?: 1) as int
          if (attempts >= 3) {
            running.status = 'failed'
            running.error  = errMsg
            (q2.deadLetter as List) << running
          } else {
            // Requeue fairly: reset status/processor; keep original receivedAt so FIFO within priority is preserved
            running.status    = 'queued'
            running.processor = null
            q2.jobs << running
          }
        }
      }

      writeFile file: 'queue.json', text: groovy.json.JsonOutput.prettyPrint(toJsonString([jobs: q2.jobs, deadLetter: q2.deadLetter]))
    }
  }
}

/* ============================ Shared Queue Helpers ============================ */
/*
  Uses a single stash name ('queue-json') guarded by a Jenkins lock.
  Any code inside withStashedQueue must read/modify/write 'queue.json' in CWD.
*/
def withStashedQueue(Closure body) {
  lock(resource: 'queue-json-lock') {
    // Pull latest queue.json into this workspace
    try { unstash name: 'queue-json' } catch (ignored) { /* first run, nothing stashed yet */ }

    if (!fileExists('queue.json')) {
      writeFile file: 'queue.json', text: '{"jobs":[],"deadLetter":[]}'
    }

    try {
      body.call()
    } finally {
      // Push updated queue.json back to the controller
      stash name: 'queue-json', includes: 'queue.json'
    }
  }
}

/* ============================ JSON & Param Helpers ============================ */

def buildParams(List plist) {
  def m = [:]
  (plist ?: []).each { kv ->
    if (kv?.name) m[kv.name.toString()] = (kv.value == null ? '' : kv.value.toString())
  }
  return [
    string(name: 'PARAM1', value: m['PARAM1'] ?: ''),
    string(name: 'PARAM2', value: m['PARAM2'] ?: ''),
    string(name: 'PARAM3', value: m['PARAM3'] ?: ''),
    string(name: 'PARAM4', value: m['PARAM4'] ?: '')
  ]
}

@NonCPS
def safeMerge(String existingText, String batchText, String source) {
  def existing = parsePlainSafe(existingText) ?: [jobs: [], deadLetter: []]
  if (!(existing.jobs instanceof List)) existing.jobs = []
  if (!(existing.deadLetter instanceof List)) existing.deadLetter = []

  def batch = parsePlainSafe(batchText) ?: [jobs: []]
  def now = new Date().format("yyyy-MM-dd'T'HH:mm:ssXXX")

  (batch.jobs ?: []).each { j ->
    def item = toPlain(j) ?: [:]
    if (!(item.parameters instanceof List)) item.parameters = []
    item.source     = source?.toString()
    item.receivedAt = now
    item.status     = 'queued'
    item.attempts   = 0
    existing.jobs << item
  }

  return groovy.json.JsonOutput.toJson(existing)
}

@NonCPS
def parsePlainSafe(String jsonText) {
  if (!jsonText) return null
  def t = jsonText.trim()
  if (t.length() == 0) return null
  try {
    def p = new groovy.json.JsonSlurper().parseText(t)
    return toPlain(p)
  } catch (Throwable ignored) {
    return null
  }
}

@NonCPS
def toPlain(Object o) {
  if (o instanceof Map)  { def m = [:]; o.each { k,v -> m[(k?.toString())] = toPlain(v) }; return m }
  if (o instanceof List) { def l = [];  o.each { v -> l << toPlain(v) }; return l }
  return o
}

@NonCPS
def toJsonString(Object o) { groovy.json.JsonOutput.toJson(o) }

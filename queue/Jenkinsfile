pipeline { 
  agent { label 'master' }

  parameters {
    string(name: 'ListOfJobs', defaultValue: '', description: 'Upstream JSON payload ({"jobs":[...]})')
    booleanParam(name: 'PURGE_QUEUE', defaultValue: false, description: 'If true, wipe queue.json (fresh start).')
    booleanParam(name: 'PURGE_DEADLETTER', defaultValue: false, description: 'If true, clear deadLetter only.')
    booleanParam(name: 'REQUEUE_DEADLETTER', defaultValue: false, description: 'Move all deadLetter items back to jobs (attempts=0, status=queued).')
    string(name: 'LIVE_MAX', defaultValue: '4', description: 'Max live branches (matrix axis count only)')
    string(name: 'STAGING_MAX', defaultValue: '4', description: 'Max staging branches (matrix axis count only)')
  }

  options {
    timestamps()
    buildDiscarder(logRotator(numToKeepStr: '20', daysToKeepStr: '30'))
    disableConcurrentBuilds()
  }

  environment {
    QUEUE_PATH       = 'queue.json'
    // How long a worker will wait/retry when it finds no item, to catch freshly ingested jobs
    IDLE_WAIT_SECS   = '3'     // sleep between empty polls
    IDLE_RETRIES     = '10'    // number of empty polls before branch exits
  }

  stages {

    /* ---------- Optional Purge / DLQ ops ---------- */

    stage('Optional: Purge queue/deadLetter') {
      when { expression { params.PURGE_QUEUE || params.PURGE_DEADLETTER } }
      steps {
        script {
          lock(resource: 'queue-json') {
            def cur = [jobs: [], deadLetter: []]
            if (fileExists(env.QUEUE_PATH)) {
              cur = parsePlainSafe(readFile(env.QUEUE_PATH)) ?: cur
            }
            if (params.PURGE_QUEUE) {
              cur.jobs = []
              cur.deadLetter = []
              echo 'Queue + DeadLetter wiped.'
            } else if (params.PURGE_DEADLETTER) {
              cur.deadLetter = []
              echo 'DeadLetter wiped.'
            }
            writeFile file: env.QUEUE_PATH,
                     text: groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(cur))
          }
        }
      }
    }

    stage('Optional: Requeue deadLetter') {
      when { expression { params.REQUEUE_DEADLETTER } }
      steps {
        script {
          lock(resource: 'queue-json') {
            if (!fileExists(env.QUEUE_PATH)) {
              writeFile file: env.QUEUE_PATH, text: '{"jobs":[],"deadLetter":[]}'
            }
            def cur = parsePlainSafe(readFile(env.QUEUE_PATH)) ?: [jobs: [], deadLetter: []]
            def nowIso = new Date().format("yyyy-MM-dd'T'HH:mm:ssXXX")
            def moved = 0
            (cur.deadLetter as List).each { j ->
              def x = toPlain(j)
              x.status = 'queued'
              x.attempts = 0
              x.claimId = null
              x.startedAt = null
              x.receivedAt = x.receivedAt ?: nowIso
              if (!(x.parameters instanceof List)) x.parameters = []
              if (!x.parameters.any { (it?.name as String) == 'env' }) {
                x.parameters << [name:'env', value: (x.env ?: 'staging')]
              }
              (cur.jobs as List) << x
              moved++
            }
            cur.deadLetter = []
            cur.jobs = sortJobs(cur.jobs as List)
            writeFile file: env.QUEUE_PATH,
                     text: groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(cur))
            echo "Requeued ${moved} items from deadLetter."
          }
        }
      }
    }

    /* ---------- Normal ingest path ---------- */

    stage('Ingest to queue.json') {
      steps {
        script {
          if (!fileExists(env.QUEUE_PATH)) {
            writeFile file: env.QUEUE_PATH, text: '{"jobs":[],"deadLetter":[]}'
          }
          if (!params.ListOfJobs?.trim()) {
            echo 'No ListOfJobs provided; skipping ingest.'
            return
          }

          lock(resource: 'queue-json') {
            def curText = readFile(env.QUEUE_PATH)
            def cur     = parsePlainSafe(curText) ?: [jobs: [], deadLetter: []]
            if (!(cur.jobs instanceof List))       cur.jobs = []
            if (!(cur.deadLetter instanceof List)) cur.deadLetter = []
            cur.jobs = (cur.jobs as List).findAll { it instanceof Map && it.job != null }

            def incoming = parseJobsToPlain(params.ListOfJobs) // -> [jobs:[...]]
            def nowIso   = new Date().format("yyyy-MM-dd'T'HH:mm:ssXXX")

            int added = 0
            (incoming.jobs ?: []).each { j ->
              def item = toPlain(j) ?: [:]
              if (!(item.parameters instanceof List)) item.parameters = []

              // ensure env in parameters; default to 'staging'
              def envParam = item.parameters.find { it?.name?.toString() == 'env' }
              def envValue = envParam?.value?.toString()?.toLowerCase()
              if (!envValue) {
                envValue = 'staging'
                item.parameters << [name: 'env', value: envValue]
              }
              item.env = envValue

              // keep upstream priority as-is (missing -> null -> treated as 0 at sort)
              item.status     = 'queued'
              item.attempts   = (item.attempts ?: 0) as int
              item.receivedAt = item.receivedAt ?: nowIso

              if (!item.job) {
                item.error = 'missing job name (ingest)'
                (cur.deadLetter as List) << item
              } else {
                (cur.jobs as List) << item
                added++
              }
            }

            // sort + normalize env param on any legacy entries
            cur.jobs = sortJobs(cur.jobs as List)
            cur.jobs.each { j ->
              if (!(j.parameters instanceof List)) { j.parameters = [] }
              boolean hasEnv = j.parameters.any { (it?.name as String) == 'env' }
              if (!hasEnv) {
                j.parameters << [ name: 'env', value: (j.env ?: 'staging') ]
              }
              j.env = (j.env ?: (j.parameters.find { it?.name=='env' }?.value ?: 'staging')).toString().toLowerCase()
            }

            writeFile file: env.QUEUE_PATH,
                     text: groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(cur))

            echo "Queue updated: added=${added}, totalQueued=${cur.jobs.count { it.status=='queued' }}, deadLetter=${(cur.deadLetter as List).size()}"
            echo "Current jobs: " + (cur.jobs as List).collect { it.name ?: it.job }.join(', ')
          } // lock
        }
      }
    }

    /* ---------- LIVE POOL: agent-1..4 (matrix) ---------- */

    stage('LIVE pool (matrix)') {
      matrix {
        axes {
          axis {
            name 'AGENT_LABEL'
            // keep 4; if you ever want this dynamic, switch to scripted parallel later
            values 'agent-1','agent-2','agent-3','agent-4'
          }
        }
        agent { label "${AGENT_LABEL}" }

        stages {
          stage('Live worker') {
            steps {
              script {
                // Each branch loops and keeps pulling the next best LIVE job until idle for a while
                int idleLeft = env.IDLE_RETRIES as int
                while (true) {
                  def item = claimNext('live', env.AGENT_LABEL) // atomically claim highest-priority live job
                  if (!item) {
                    if (idleLeft-- > 0) {
                      sleep time: env.IDLE_WAIT_SECS as int, unit: 'SECONDS'
                      continue
                    } else {
                      echo "[${env.AGENT_LABEL}] No LIVE work after idle window; exiting."
                      break
                    }
                  }

                  def jobName = item.job.toString()
                  def plist   = (item.parameters ?: []).collect { kv ->
                    string(name: kv.name.toString(), value: (kv.value == null ? '' : kv.value.toString()))
                  }

                  boolean ok = true
                  String err = null
                  try {
                    echo "[${env.AGENT_LABEL}] ▶ LIVE ${item.name ?: jobName} (prio=${item.priority ?: 0})"
                    build job: jobName, wait: true, propagate: true, parameters: plist
                    echo "[${env.AGENT_LABEL}] ✔ LIVE done ${item.name ?: jobName}"
                  } catch (e) {
                    ok = false
                    err = e.getMessage()
                    echo "[${env.AGENT_LABEL}] ✖ LIVE fail ${item.name ?: jobName}: ${err}"
                  }

                  finalizeOne(item, ok, err)
                  // Reset idle wait since we just did work; keep looping
                  idleLeft = env.IDLE_RETRIES as int
                } // while
              } // script
            } // steps
          } // stage
        } // stages
      } // matrix
    }

    /* ---------- STAGING POOL: staging-1..4 (matrix) ---------- */

    stage('STAGING pool (matrix)') {
      matrix {
        axes {
          axis {
            name 'AGENT_LABEL'
            values 'staging-1','staging-2','staging-3','staging-4'
          }
        }
        agent { label "${AGENT_LABEL}" }

        stages {
          stage('Staging worker') {
            steps {
              script {
                // Each branch loops and keeps pulling the next best STAGING job until idle for a while
                int idleLeft = env.IDLE_RETRIES as int
                while (true) {
                  def item = claimNext('staging', env.AGENT_LABEL) // atomically claim highest-priority staging job
                  if (!item) {
                    if (idleLeft-- > 0) {
                      sleep time: env.IDLE_WAIT_SECS as int, unit: 'SECONDS'
                      continue
                    } else {
                      echo "[${env.AGENT_LABEL}] No STAGING work after idle window; exiting."
                      break
                    }
                  }

                  def jobName = item.job.toString()
                  def plist   = (item.parameters ?: []).collect { kv ->
                    string(name: kv.name.toString(), value: (kv.value == null ? '' : kv.value.toString()))
                  }

                  boolean ok = true
                  String err = null
                  try {
                    echo "[${env.AGENT_LABEL}] ▶ STAGING ${item.name ?: jobName} (prio=${item.priority ?: 0})"
                    build job: jobName, wait: true, propagate: true, parameters: plist
                    echo "[${env.AGENT_LABEL}] ✔ STAGING done ${item.name ?: jobName}"
                  } catch (e) {
                    ok = false
                    err = e.getMessage()
                    echo "[${env.AGENT_LABEL}] ✖ STAGING fail ${item.name ?: jobName}: ${err}"
                  }

                  finalizeOne(item, ok, err)
                  // Reset idle wait since we just did work; keep looping
                  idleLeft = env.IDLE_RETRIES as int
                } // while
              } // script
            } // steps
          } // stage
        } // stages
      } // matrix
    }
  } // stages

  post {
    always {
      script {
        if (fileExists(env.QUEUE_PATH)) {
          def cur = parsePlainSafe(readFile(env.QUEUE_PATH)) ?: [jobs:[], deadLetter:[]]
          echo "Final queue: queued=${cur.jobs.count{ it.status=='queued' }}, running=${cur.jobs.count{ it.status=='running' }}, deadLetter=${(cur.deadLetter as List).size()}"
          echo "Remaining jobs: " + (cur.jobs as List).collect{ it.name ?: it.job }.join(', ')
        }
      }
    }
  }
}

/* ----------------------- Helpers (CPS-safe) ----------------------- */

// Atomically claim the next job for env ('live' | 'staging') and brand it with this branch label as claimId
@NonCPS
def _pickNextForEnv(List jobs, String envName) {
  // jobs should already be plain maps
  def idx = -1
  for (int i = 0; i < jobs.size(); i++) {
    def j = jobs[i]
    def status = (j?.status ?: 'queued').toString()
    def je = (j?.env ?: (j?.parameters?.find{ it?.name=='env' }?.value ?: 'staging')).toString().toLowerCase()
    if (status == 'queued' && je == envName) {
      idx = i; break
    }
  }
  return idx
}

def claimNext(String envName, String claimKey) {
  def claimed = null
  lock(resource: 'queue-json') {
    if (!fileExists(env.QUEUE_PATH)) {
      writeFile file: env.QUEUE_PATH, text: '{"jobs":[],"deadLetter":[]}'
    }
    def cur = parsePlainSafe(readFile(env.QUEUE_PATH)) ?: [jobs:[], deadLetter:[]]
    if (!(cur.jobs instanceof List))       cur.jobs = []
    if (!(cur.deadLetter instanceof List)) cur.deadLetter = []

    // normalize & sort before picking
    cur.jobs.each { j ->
      if (!(j.parameters instanceof List)) j.parameters = []
      if (!j.parameters.any { (it?.name as String) == 'env' }) {
        j.parameters << [ name:'env', value:(j.env ?: 'staging') ]
      }
      j.env = (j.env ?: (j.parameters.find { it?.name=='env' }?.value ?: 'staging')).toString().toLowerCase()
    }
    cur.jobs = sortJobs(cur.jobs as List)

    // find first queued job for requested env
    def idx = _pickNextForEnv(cur.jobs as List, envName)
    if (idx >= 0) {
      def nowIso  = new Date().format("yyyy-MM-dd'T'HH:mm:ssXXX")
      def item = toPlain(cur.jobs[idx])
      item.status    = 'running'
      item.claimId   = claimKey
      item.startedAt = nowIso
      cur.jobs[idx]  = item
      claimed = toPlain(item)
      writeFile file: env.QUEUE_PATH,
               text: groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(cur))
    }
  } // lock
  return claimed
}

def finalizeOne(Map item, boolean ok, String err) {
  // finalize under lock on master
  node('master') {
    lock(resource: 'queue-json') {
      def cur = parsePlainSafe(readFile(env.QUEUE_PATH)) ?: [jobs:[], deadLetter:[]]
      if (!(cur.jobs instanceof List))       cur.jobs = []
      if (!(cur.deadLetter instanceof List)) cur.deadLetter = []

      int idx = (cur.jobs as List).findIndexOf { j ->
        (j?.status == 'running') &&
        (j?.claimId?.toString()   == item.claimId?.toString()) &&
        (j?.job?.toString()       == item.job?.toString()) &&
        ((j?.name?.toString() ?: '') == (item.name?.toString() ?: '')) &&
        (j?.startedAt?.toString() == item.startedAt?.toString())
      }

      if (idx >= 0) {
        def j = cur.jobs[idx]
        if (ok) {
          cur.jobs.remove(idx)
        } else {
          int attempts = ((j.attempts ?: 0) as int) + 1
          j.attempts = attempts
          if (attempts >= 3) {
            j.status = 'failed'
            j.error  = err ?: 'unknown'
            (cur.deadLetter as List) << j
            cur.jobs.remove(idx)
          } else {
            j.status    = 'queued'
            j.claimId   = null
            j.startedAt = null
            cur.jobs[idx] = j
          }
        }
        writeFile file: env.QUEUE_PATH,
                 text: groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(cur))
      } else {
        echo "[${item?.claimId}] WARN: Claimed item not found during finalize."
      }
    } // lock
  } // node
}

@NonCPS
def parseJobsToPlain(String raw) {
  def sl = new groovy.json.JsonSlurper()
  Object obj
  try { obj = sl.parseText(raw?.trim()) } catch (e) {
    throw new Exception("Invalid JSON (${e.message}). First 200 chars: ${raw?.take(200)}")
  }
  if (obj instanceof String) obj = sl.parseText(obj) // handle double-encoded
  if (obj instanceof List)   obj = [jobs: obj]
  else if (!(obj instanceof Map) || !(obj.jobs instanceof List))
    throw new Exception('Expected top-level {"jobs":[...]} or a bare array.')
  return toPlain(obj)
}

@NonCPS
def parsePlainSafe(String text) {
  if (!text) return null
  try {
    def p = new groovy.json.JsonSlurper().parseText(text.trim())
    if (p instanceof String) p = new groovy.json.JsonSlurper().parseText(p)
    return toPlain(p)
  } catch (ignored) { return null }
}

@NonCPS
def toPlain(Object o) {
  if (o instanceof Map)  { def m = [:]; o.each { k,v -> m[(k?.toString())] = toPlain(v) }; return m }
  if (o instanceof List) { return o.collect { toPlain(it) } }
  return o
}

@NonCPS
def sortJobs(List jobs) {
  if (!(jobs instanceof List)) return []
  def copy = jobs.collect { toPlain(it) }
  copy.sort { a, b ->
    int pa = ((a?.priority) ?: 0) as int
    int pb = ((b?.priority) ?: 0) as int
    def cmp = (pb <=> pa)  // higher priority first
    if (cmp != 0) return cmp
    String ra = (a?.receivedAt ?: '')
    String rb = (b?.receivedAt ?: '')
    return (ra <=> rb)     // FIFO among same priority
  }
  return copy
}

// agent-1 -> 0, agent-2 -> 1, staging-1 -> 0, ...
@NonCPS
def indexFromAgent(String label) {
  if (!label) return -1
  try {
    def parts = label.split('-')
    return Math.max(0, Integer.parseInt(parts[-1]) - 1)
  } catch (ignored) {
    return -1
  }
}
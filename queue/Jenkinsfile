pipeline {
  agent { label 'master' }
  parameters {
    string(name: 'ListOfJobs', defaultValue: '', description: 'Upstream JSON')
  }
  options { buildDiscarder(logRotator(numToKeepStr: '15', daysToKeepStr: '30')) }
  environment { BUILD_TRIGGER_BY = 'unknown' }

  stages {
    stage('prep') {
      steps {
        script {
          if (!params.ListOfJobs?.trim()) {
            error 'ListOfJobs is empty; expected JSON payload from upstream.'
          }

          def incomingJobs = parseJobsToPlain(params.ListOfJobs)

          def stagingJobs = incomingJobs.jobs.findAll { job ->
            (job.parameters ?: []).find { p -> p.name == 'env' && p.value?.toString()?.toLowerCase() == 'staging' }
          }
          def liveJobs = incomingJobs.jobs.findAll { job ->
            (job.parameters ?: []).find { p -> p.name == 'env' && p.value?.toString()?.toLowerCase() == 'live' }
          }

          echo "Staging jobs: ${stagingJobs.collect { it.name ?: it.job }}"
          echo "Live jobs: ${liveJobs.collect { it.name ?: it.job }}"

          writeFile file: 'live_queue.json',    text: groovy.json.JsonOutput.toJson(liveJobs)
          writeFile file: 'staging_queue.json', text: groovy.json.JsonOutput.toJson(stagingJobs)
        }
      }
    }

    stage('live run') {
      when { expression { fileExists('live_queue.json') && readFile('live_queue.json')?.trim() && readFile('live_queue.json').trim() != '[]' } }
      steps {
        script {
          // ✅ Parse via NonCPS helper (returns plain List/Map), not JsonSlurper here
          def liveJobs = parsePlainSafe(readFile('live_queue.json')) as List
          echo "n: ${liveJobs.collect { it.name ?: it.job }.join(', ')}"
          echo "Starting live run for ${liveJobs}"
        }
      }
    }

    stage('staging run') {
      when { expression { fileExists('staging_queue.json') && readFile('staging_queue.json')?.trim() && readFile('staging_queue.json').trim() != '[]' } }
      steps {
        script {
          // ✅ Parse via NonCPS helper
          def stagingJobs = parsePlainSafe(readFile('staging_queue.json')) as List
          echo "n: ${stagingJobs.collect { it.name ?: it.job }.join(', ')}"
        }
      }
    }
  }
}

/* ---- Helpers (no plugins, CPS-safe) ---- */
@NonCPS
def parseJobsToPlain(String raw) {
  def slurper = new groovy.json.JsonSlurper()
  Object obj = slurper.parseText(raw?.trim())
  if (obj instanceof String) obj = slurper.parseText(obj) // handle double-encoded
  if (obj instanceof List) obj = [jobs: obj]
  else if (!(obj instanceof Map) || !(obj.jobs instanceof List))
    throw new Exception('Expected top-level {"jobs":[...]} or bare array.')
  return toPlain(obj) // plain Map/List
}

@NonCPS
def parsePlainSafe(String jsonText) {
  if (!jsonText) return null
  def p = new groovy.json.JsonSlurper().parseText(jsonText.trim())
  if (p instanceof String) p = new groovy.json.JsonSlurper().parseText(p)
  return toPlain(p) // plain Map/List
}

@NonCPS
def toPlain(Object obj) {
  if (obj instanceof Map)  { def m = [:]; obj.each { k,v -> m[k?.toString()] = toPlain(v) }; return m }
  if (obj instanceof List) { return obj.collect { toPlain(it) } }
  return obj
}

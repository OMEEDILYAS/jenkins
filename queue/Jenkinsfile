// Jenkinsfile — controller-orchestrated matrix across 4 agents

pipeline {
  // Top-level agent: run orchestration on the controller (change to 'master' if your controller label is 'master')
  agent { label 'built-in' }

  options {
    timestamps()
    disableConcurrentBuilds()
    buildDiscarder(logRotator(numToKeepStr: '10')) // keep only last 10 builds
  }

  parameters {
    // Add/adjust as needed
    string(name: 'PARAM1', defaultValue: '', description: 'Free-form parameter 1')
    choice(name: 'RUN_MODE', choices: ['fast', 'normal', 'slow'], description: 'Example choice param')
  }

  // We'll populate BUILD_BY at runtime (no extra plugins required)
  environment {
    BUILD_BY = ''  // will be set in Init stage
  }

  stages {
    stage('Init') {
      steps {
        script {
          env.BUILD_BY = getBuildUser() ?: 'SYSTEM'
          echo "Build triggered by: ${env.BUILD_BY}"
        }
      }
    }

    stage('workflow') {
      matrix {
        axes {
          axis {
            name 'AGENT'                // use 'AGENT' to avoid clashing with the 'agent {}' directive
            values 'agent-1', 'agent-2', 'agent-3', 'agent-4'
          }
        }

        stages {
          stage('work') {
            // Run this leg on the specific agent label
            agent { label "${AGENT}" }

            steps {
              script {
                echo "Leg for ${AGENT} running on node: ${env.NODE_NAME}, started by ${env.BUILD_BY}"
                // >>> Your main work goes here:
                // Example: doWork() encapsulates the logic you want to run on each worker
                doWork(AGENT, params)
              }
            }
          }
        }
      }
    }
  }

  post {
    always {
      echo "Done. Built by ${env.BUILD_BY}"
    }
  }
}

/* ========================= Helper functions ========================= */

// Returns the username who started the build (no extra plugin needed).
// Works for user, timer, SCM, upstream, etc. Falls back gracefully.
@NonCPS
def getBuildUser() {
  def causes = currentBuild.rawBuild?.getCauses() ?: []
  // Prefer UserIdCause / UserCause if present
  def userCause = causes.find { it.class.simpleName.contains('UserIdCause') || it.class.simpleName.contains('UserCause') }
  if (userCause) {
    // Try common getters without importing plugin classes
    def u = null
    try { u = userCause.getUserId() } catch (ignored) {}
    try { if (!u) u = userCause.getUserName() } catch (ignored) {}
    return (u ?: 'unknown-user').toString()
  }
  // Timer, SCM, upstream, etc.
  def first = causes ? causes[0] : null
  return first ? first.getShortDescription() : 'non-interactive-trigger'
}

// Put your per-node work here.
// You can add shell steps, git operations, build triggers, etc.
def doWork(String agentLabel, def paramsObj) {
  echo "doWork() on ${agentLabel} with RUN_MODE=${paramsObj.RUN_MODE}, PARAM1=${paramsObj.PARAM1}"

  // Example workload — replace with your real steps
  if (isUnix()) {
    sh """
      echo "[\$(date +%T)] ${agentLabel}: starting work (mode=${paramsObj.RUN_MODE})"
      sleep 2
      echo "[\$(date +%T)] ${agentLabel}: finishing work"
    """
  } else {
    powershell """
      Write-Host "[\$(Get-Date -Format T)] ${agentLabel}: starting work (mode=${paramsObj.RUN_MODE})"
      Start-Sleep -Seconds 2
      Write-Host "[\$(Get-Date -Format T)] ${agentLabel}: finishing work"
    """
  }
}

pipeline {
  agent { label 'master' }

  parameters {
    string(name: 'ListOfJobs', defaultValue: '', description: 'Upstream JSON payload ({"jobs":[...]})')
  }

  options {
    timestamps()
    buildDiscarder(logRotator(numToKeepStr: '20', daysToKeepStr: '30'))
  }

  environment {
    // Path for the unified queue; adjust if you prefer a different location.
    QUEUE_PATH = 'queue.json'
  }

  stages {

    stage('Ingest to queue.json') {
      steps {
        script {
          if (!params.ListOfJobs?.trim()) {
            error 'ListOfJobs is empty; expected JSON payload from upstream.'
          }

          // Create base file if missing (kept tiny to avoid race; real serialization is the lock)
          if (!fileExists(env.QUEUE_PATH)) {
            writeFile file: env.QUEUE_PATH, text: '{"jobs":[],"deadLetter":[]}'
          }

          // All queue reads/writes serialized by a single lock
          lock(resource: 'queue-json') {
            // 1) Read current queue
            def curText = readFile(env.QUEUE_PATH)
            def curRaw  = parsePlainSafe(curText)

            // normalize the current queue to a Map with jobs/deadLetter
            def cur
            if (curRaw instanceof Map) {
              cur = curRaw
            } else if (curRaw instanceof List) {
              // someone wrote a bare array in a previous run; wrap it
              cur = [jobs: curRaw, deadLetter: []]
            } else {
              cur = [jobs: [], deadLetter: []]
            }

            if (!(cur.jobs instanceof List))       cur.jobs = []
            if (!(cur.deadLetter instanceof List)) cur.deadLetter = []

            // ðŸ”’ Harden existing queue content (remove nulls / non-maps / items missing job)
            cur.jobs = (cur.jobs as List).findAll { it instanceof Map && it.job != null }

            // 2) Parse incoming
            def incoming = parseJobsToPlain(params.ListOfJobs) // returns [jobs: [...]]
            def nowIso = new Date().format("yyyy-MM-dd'T'HH:mm:ssXXX")

            // 3) Normalize & append
            int added = 0
            (incoming.jobs ?: []).each { j ->
              def item = toPlain(j) ?: [:]
              if (!(item.parameters instanceof List)) item.parameters = []

              // Extract env from parameters; if missing, default to "staging" and add it to parameters
              def envParam = item.parameters.find { it?.name?.toString() == 'env' }
              def envValue = envParam?.value?.toString()?.toLowerCase()
              if (!envValue) {
                envValue = 'staging' // <-- default per your rule
                item.parameters << [name: 'env', value: envValue]
              }
              item.env = envValue  // top-level copy for fast filtering later
              echo "Job '${item.name ?: item.job}' assigned to env='${item.env}'"

              // Default priority if missing/invalid
              def pr = null
              try { pr = (item.priority as Integer) } catch (ignored) {}
              if (pr == null) pr = 6           // <-- default per your rule
              item.priority = pr
              // echo the priority of the job that didn't have it set
              echo "Job '${item.name ?: item.job}' assigned priority='${item.priority}'"

              // Ensure core fields
              item.status     = 'queued'
              item.attempts   = (item.attempts ?: 0) as int
              item.receivedAt = item.receivedAt ?: nowIso

              // Minimal validation: must have a downstream job name
              if (!item.job) {
                item.error = 'missing job name'
                (cur.deadLetter as List) << item
              } else {
                (cur.jobs as List) << item
                added++
              }
            }

            // Optional: keep a light sort (priority desc, then FIFO by receivedAt)
            (cur.jobs as List).sort { x, y ->
            def a = (x instanceof Map) ? x : [:]
            def b = (y instanceof Map) ? y : [:]
            int pa = (a.priority ?: 0) as int
            int pb = (b.priority ?: 0) as int
            def byPrio = (pb <=> pa)
            return (byPrio != 0) ? byPrio : ((a.receivedAt ?: '') <=> (b.receivedAt ?: ''))
          }
            // 4) Write back pretty JSON
            def outText = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(cur))
            writeFile file: env.QUEUE_PATH, text: outText

            echo "Queue updated: added=${added}, totalQueued=${cur.jobs.count { it.status=='queued' }}, deadLetter=${(cur.deadLetter as List).size()}"
            def names = (cur.jobs as List).collect { it.name ?: it.job }.join(', ')
            echo "Current jobs: ${names}"
          } // lock
        }
      }
    }
  }
}

/* ----------------------- Helpers (CPS-safe) ----------------------- */

@NonCPS
def parseJobsToPlain(String raw) {
  def sl = new groovy.json.JsonSlurper()
  Object obj
  try {
    obj = sl.parseText(raw?.trim())
  } catch (e) {
    throw new Exception("Invalid JSON (${e.message}). First 200 chars: ${raw?.take(200)}")
  }
  if (obj instanceof String) { // double-encoded safeguard
    obj = sl.parseText(obj)
  }
  if (obj instanceof List) {
    obj = [jobs: obj]
  } else if (!(obj instanceof Map) || !(obj.jobs instanceof List)) {
    throw new Exception('Expected top-level {"jobs":[...]} or a bare array.')
  }
  return toPlain(obj)
}

@NonCPS
def parsePlainSafe(String text) {
  if (!text) return null
  try {
    def p = new groovy.json.JsonSlurper().parseText(text.trim())
    if (p instanceof String) p = new groovy.json.JsonSlurper().parseText(p)
    return toPlain(p)
  } catch (ignored) {
    return null
  }
}

@NonCPS
def toPlain(Object o) {
  if (o instanceof Map)  { def m = [:]; o.each { k,v -> m[(k?.toString())] = toPlain(v) }; return m }
  if (o instanceof List) { return o.collect { toPlain(it) } }
  return o
}

pipeline {
  agent { label 'master' }
  parameters {
    string(name: 'ListOfJobs', defaultValue: '', description: 'Upstream JSON')
  }
  options { buildDiscarder(logRotator(numToKeepStr: '15', daysToKeepStr: '30')) }
  environment { BUILD_TRIGGER_BY = 'unknown' }

  stages {
    /* ===== LIVE: matrix across agent-1..4 ===== */
stage('live run') {
  when { expression { fileExists('live_queue.json') && readFile('live_queue.json')?.trim() && readFile('live_queue.json').trim() != '[]' } }
  matrix {
    axes {
      axis {
        name 'AGENT_LABEL'
        values 'agent-1', 'agent-2', 'agent-3', 'agent-4'
      }
    }
    agent { label "${AGENT_LABEL}" }

    stages {
      stage('Live worker') {
        steps {
          script {
            // Parse once, then shard by agent
            def allLive = parsePlainSafe(readFile('live_queue.json')) as List

            // Map each agent label to an index 0..3 for sharding
            def shardIndex = ['agent-1':0, 'agent-2':1, 'agent-3':2, 'agent-4':3][env.AGENT_LABEL] as int
            int shards = 4

            // Take only the jobs for this shard
            def myJobs = []
            allLive.eachWithIndex { j, i ->
              if ((i % shards) == shardIndex) { myJobs << j }
            }

            echo "[${env.AGENT_LABEL}] live shard size=${myJobs.size()} of total=${allLive.size()}"
            echo "[${env.AGENT_LABEL}] jobs: ${myJobs.collect { it.name ?: it.job }.join(', ')}"

            // Helper to convert params to Jenkins parameter list
            def toParamList = { plist ->
              (plist ?: []).collect { p ->
                string(name: p.name.toString(), value: (p.value == null ? '' : p.value.toString()))
              }
            }

            myJobs.each { j ->
              def target = j.job?.toString()
              if (!target) { error "[${env.AGENT_LABEL}] Job '${j.name}' missing 'job' field." }
              echo "[${env.AGENT_LABEL}] ▶ live: ${j.name} -> ${target}"
              build job: target, wait: true, parameters: toParamList(j.parameters)
            }
          }
        }
      }
    }
  }
}

/* ===== STAGING: matrix across agent-1..4 ===== */
stage('staging run') {
  when { expression { fileExists('staging_queue.json') && readFile('staging_queue.json')?.trim() && readFile('staging_queue.json').trim() != '[]' } }
  matrix {
    axes {
      axis {
        name 'AGENT_LABEL'
        values 'agent-1', 'agent-2', 'agent-3', 'agent-4'
      }
    }
    agent { label "${AGENT_LABEL}" }

    stages {
      stage('Staging worker') {
        steps {
          script {
            def allStaging = parsePlainSafe(readFile('staging_queue.json')) as List

            def shardIndex = ['agent-1':0, 'agent-2':1, 'agent-3':2, 'agent-4':3][env.AGENT_LABEL] as int
            int shards = 4

            def myJobs = []
            allStaging.eachWithIndex { j, i ->
              if ((i % shards) == shardIndex) { myJobs << j }
            }

            echo "[${env.AGENT_LABEL}] staging shard size=${myJobs.size()} of total=${allStaging.size()}"
            echo "[${env.AGENT_LABEL}] jobs: ${myJobs.collect { it.name ?: it.job }.join(', ')}"

            def toParamList = { plist ->
              (plist ?: []).collect { p ->
                string(name: p.name.toString(), value: (p.value == null ? '' : p.value.toString()))
              }
            }

            myJobs.each { j ->
              def target = j.job?.toString()
              if (!target) { error "[${env.AGENT_LABEL}] Job '${j.name}' missing 'job' field." }
              echo "[${env.AGENT_LABEL}] ▶ staging: ${j.name} -> ${target}"
              build job: target, wait: true, parameters: toParamList(j.parameters)
            }
          }
        }
      }
    }
  }
}

  }
}

/* ---- Helpers (no plugins, CPS-safe) ---- */
@NonCPS
def parseJobsToPlain(String raw) {
  def slurper = new groovy.json.JsonSlurper()
  Object obj = slurper.parseText(raw?.trim())
  if (obj instanceof String) obj = slurper.parseText(obj) // handle double-encoded
  if (obj instanceof List) obj = [jobs: obj]
  else if (!(obj instanceof Map) || !(obj.jobs instanceof List))
    throw new Exception('Expected top-level {"jobs":[...]} or bare array.')
  return toPlain(obj) // plain Map/List
}

@NonCPS
def parsePlainSafe(String jsonText) {
  if (!jsonText) return null
  def p = new groovy.json.JsonSlurper().parseText(jsonText.trim())
  if (p instanceof String) p = new groovy.json.JsonSlurper().parseText(p)
  return toPlain(p) // plain Map/List
}

@NonCPS
def toPlain(Object obj) {
  if (obj instanceof Map)  { def m = [:]; obj.each { k,v -> m[k?.toString()] = toPlain(v) }; return m }
  if (obj instanceof List) { return obj.collect { toPlain(it) } }
  return obj
}

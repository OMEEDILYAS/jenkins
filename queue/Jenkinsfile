pipeline {
  agent {
    label 'master'
  }
  parameters {
    string(name: 'ListOfJobs', defaultValue: '', description: 'upstream jobs to run')
  }
  options {
    buildDiscarder(logRotator(numToKeepStr: '15', daysToKeepStr: '30'))
  }
  // ⚠️ You can’t call methods inside environment; remove this or move into a script if you need it.
  environment {
    BUILD_TRIGGER_BY = 'unknown'
  }
  stages {
    stage('prep') {
      steps {
        script {
          try {
            def incomingJobs = new groovy.json.JsonSlurper().parseText(params.ListOfJobs)
            echo "Incoming jobs type: ${incomingJobs.getClass()}"
            echo "Incoming jobs content: ${incomingJobs}"

            if (!(incomingJobs instanceof Map) || !(incomingJobs.jobs instanceof List)) {
              error "ListOfJobs parameter is not a valid JSON object with 'jobs' array."
            }

            // Convert to plain structures so LazyMap doesn't break CPS
            incomingJobs = toPlain(incomingJobs)
            echo "Converted jobs to plain object: ${incomingJobs}"

            def stagingJobs = incomingJobs.jobs.findAll { job ->
              job.parameters.find { param ->
                param.name == 'env' && param.value == 'staging'
              }
            }
            def liveJobs = incomingJobs.jobs.findAll { job ->
              job.parameters.find { param ->
                param.name == 'env' && param.value == 'live'
              }
            }

            echo "Staging jobs: ${stagingJobs.collect { it.name }}"
            echo "Live jobs: ${liveJobs.collect { it.name }}"
          } catch (Exception e) {
            error "Error parsing ListOfJobs parameter: ${e.message}"
          }
        }
      }
    }
    stage('live run') {
      steps {
        script {
          echo "Live run for jobs: ${params.ListOfJobs}"
        }
      }
    }
    stage('staging run') {
      steps {
        script {
          echo "Staging run for jobs: ${params.ListOfJobs}"
        }
      }
    }
  }
}

@NonCPS
def toPlain(Object obj) {
  if (obj instanceof Map) {
    def plainMap = [:]
    obj.each { key, value ->
      plainMap[key.toString()] = toPlain(value)  // ✅ fixed: 'key', not 'k'
    }
    return plainMap
  } else if (obj instanceof List) {
    def plainList = []
    obj.each { item ->
      plainList.add(toPlain(item))
    }
    return plainList
  } else {
    return obj  // ✅ return value directly, no echo or error here
  }
}

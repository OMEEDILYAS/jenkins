pipeline {
  agent { label 'master' }
  parameters {
    string(name: 'ListOfJobs', defaultValue: '', description: 'Upstream JSON')
  }
  options { buildDiscarder(logRotator(numToKeepStr: '15', daysToKeepStr: '30')) }
  environment { BUILD_TRIGGER_BY = 'unknown' }

  stages {
    stage('live run') {
  when { expression { fileExists('live_queue.json') && readFile('live_queue.json')?.trim() && readFile('live_queue.json').trim() != '[]' } }
  steps {
    script {
      def liveJobs = parsePlainSafe(readFile('live_queue.json')) as List
      echo "n: ${liveJobs.collect { it.name ?: it.job }.join(', ')}"

      // helper to convert parameters array -> Jenkins parameter list
      def toParamList = { plist ->
        (plist ?: []).collect { p ->
          string(name: p.name.toString(), value: (p.value == null ? '' : p.value.toString()))
        }
      }

      // build each job individually
      liveJobs.each { j ->
        def target = j.job?.toString()
        if (!target) { error "Live job '${j.name}' is missing a 'job' field." }
        echo "Starting live run: ${j.name} -> ${target}"
        build job: target, wait: true, parameters: toParamList(j.parameters)
      }
    }
  }
}

stage('staging run') {
  when { expression { fileExists('staging_queue.json') && readFile('staging_queue.json')?.trim() && readFile('staging_queue.json').trim() != '[]' } }
  steps {
    script {
      def stagingJobs = parsePlainSafe(readFile('staging_queue.json')) as List
      echo "n: ${stagingJobs.collect { it.name ?: it.job }.join(', ')}"

      def toParamList = { plist ->
        (plist ?: []).collect { p ->
          string(name: p.name.toString(), value: (p.value == null ? '' : p.value.toString()))
        }
      }

      stagingJobs.each { j ->
        def target = j.job?.toString()
        if (!target) { error "Staging job '${j.name}' is missing a 'job' field." }
        echo "Starting staging run: ${j.name} -> ${target}"
        build job: target, wait: true, parameters: toParamList(j.parameters)
      }
    }
  }
}
  }
}

/* ---- Helpers (no plugins, CPS-safe) ---- */
@NonCPS
def parseJobsToPlain(String raw) {
  def slurper = new groovy.json.JsonSlurper()
  Object obj = slurper.parseText(raw?.trim())
  if (obj instanceof String) obj = slurper.parseText(obj) // handle double-encoded
  if (obj instanceof List) obj = [jobs: obj]
  else if (!(obj instanceof Map) || !(obj.jobs instanceof List))
    throw new Exception('Expected top-level {"jobs":[...]} or bare array.')
  return toPlain(obj) // plain Map/List
}

@NonCPS
def parsePlainSafe(String jsonText) {
  if (!jsonText) return null
  def p = new groovy.json.JsonSlurper().parseText(jsonText.trim())
  if (p instanceof String) p = new groovy.json.JsonSlurper().parseText(p)
  return toPlain(p) // plain Map/List
}

@NonCPS
def toPlain(Object obj) {
  if (obj instanceof Map)  { def m = [:]; obj.each { k,v -> m[k?.toString()] = toPlain(v) }; return m }
  if (obj instanceof List) { return obj.collect { toPlain(it) } }
  return obj
}

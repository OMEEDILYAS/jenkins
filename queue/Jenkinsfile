pipeline {
  agent { label 'master' }
  parameters {
    string(name: 'ListOfJobs', defaultValue: '', description: 'Upstream JSON')
  }
  options {
    buildDiscarder(logRotator(numToKeepStr: '15', daysToKeepStr: '30'))
  }
  environment {
    BUILD_TRIGGER_BY = 'unknown'
  }
  stages {
    stage('prep') {
      steps {
        script {
          if (!params.ListOfJobs?.trim()) {
            error 'ListOfJobs is empty; expected JSON payload from upstream.'
          }

          def incomingJobs = parseJobsToPlain(params.ListOfJobs)

          def stagingJobs = incomingJobs.jobs.findAll { job ->
            (job.parameters ?: []).find { p -> p.name == 'env' && p.value?.toString()?.toLowerCase() == 'staging' }
          }
          def liveJobs = incomingJobs.jobs.findAll { job ->
            (job.parameters ?: []).find { p -> p.name == 'env' && p.value?.toString()?.toLowerCase() == 'live' }
          }

          echo "Staging jobs: ${stagingJobs.collect { it.name ?: it.job }}"
          echo "Live jobs: ${liveJobs.collect { it.name ?: it.job }}"

          writeFile file: 'live_queue.json',    text: groovy.json.JsonOutput.toJson(liveJobs)
          writeFile file: 'staging_queue.json', text: groovy.json.JsonOutput.toJson(stagingJobs)
        }
      }
    }

    stage('live run') {
      when { expression { fileExists('live_queue.json') && readFile('live_queue.json')?.trim() && readFile('live_queue.json').trim() != '[]' } }
      steps {
        script {
          def liveJobs = new groovy.json.JsonSlurper().parseText(readFile('live_queue.json'))
          echo "n: ${liveJobs.collect { it.name ?: it.job }.join(', ')}"
        }
      }
    }

    stage('staging run') {
      when { expression { fileExists('staging_queue.json') && readFile('staging_queue.json')?.trim() && readFile('staging_queue.json').trim() != '[]' } }
      steps { 
        script {
          def stagingJobs = new groovy.json.JsonSlurper().parseText(readFile('staging_queue.json'))
          echo "n: ${stagingJobs.collect { it.name ?: it.job }.join(', ')}"  // <-- fixed
        }
      }
    }
  }
}

// ---- Helpers (no plugins, CPS-safe) ----
@NonCPS
def parseJobsToPlain(String raw) {
  def slurper = new groovy.json.JsonSlurper()
  Object obj
  try {
    obj = slurper.parseText(raw)
  } catch (e) {
    throw new Exception("Invalid JSON (${e.message}). First 200 chars: ${raw.take(200)}")
  }
  if (obj instanceof String) {
    obj = slurper.parseText(obj)
  }
  if (obj instanceof List) {
    obj = [jobs: obj]
  } else if (!(obj instanceof Map) || !(obj.jobs instanceof List)) {
    throw new Exception("Expected top-level {\"jobs\":[...]} or a bare [ ... ]. Got ${obj?.getClass()?.name}.")
  }
  return toPlain(obj)
}

@NonCPS
def toPlain(Object obj) {
  if (obj instanceof Map) {
    def m = [:]
    obj.each { key, value -> m[key?.toString()] = toPlain(value) }
    return m
  } else if (obj instanceof List) {
    return obj.collect { toPlain(it) }
  } else {
    return obj
  }
}
